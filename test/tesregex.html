<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
  <script src="./semantic-ui/jquery-3.2.1.min.js"></script>
  <link rel="stylesheet" href="./semantic-ui/semantic.min.css">
  <script src="./semantic-ui/semantic.min.js"></script>
  <title>Adafruit GFX Font Preview</title>
    <style>
    html, body {
      margin: 0 10px;
	  scroll-behavior: smooth;
            background-color: #000;
            font-family: Verdana, sans-serif;
            justify-content: center;
			color:cyan;
	}
        #sidebar {
            width: 300px;
            border-right: 1px solid #ccc;
            padding: 10px;
            overflow-y: auto;
            height: 100vh;
        }
        #preview {
            flex-grow: 1;
            padding: 10px;
        }
        ul {
            list-style-type: none;
            padding-left: 20px;
        }
        ul ul {
            margin-left: 10px;
        }
        .folder {
            font-weight: bold;
            cursor: pointer;
        }
        .file {
            cursor: pointer;
        }
    textarea {
      font-family: "Courier", monotype;
      font-size: 0.9em !important;
    }
        canvas {
		align:left;
		max-width:97%;
            border: 1px solid #fff;
            margin-top: 20px;
        }
    </style>
</head>
<body>
		<div class="eight wide column" id="sumber">
		  <div class="ui black inverted segment">
			<div class="ui form">
	<div class="two fields">
		<div class="field" style="width:max-content">
			<div id="sidebar">
				<button id="openDirectoryButton">Open Directory</button>
				<div id="directoryTree"></div>
			</div>
		</div>
		
		<div class="field" style="width:100%">
			<h1>Adafruit GFX Font Preview</h1>
			<textarea id="fileContent"></textarea>
			<br>
			<br>
			Zoom Scale 
			<input type="number" min="1" id="FontZoom" value="4" style="width: 100px;"></input>
			<button class="ui inverted violet button" id="FontPreview"><i class="icon upload"></i> Preview Font</button>
			<br>
			<canvas id="fontCanvas" ></canvas>
		</div>
    </div>

				</div>
			</div>
		</div>
		
		
		
    <script>
	
        document.getElementById('openDirectoryButton')
            .addEventListener('click', selectDirectory);
        async function selectDirectory() {
            try {
                const directoryHandle = await window.showDirectoryPicker();
                const rootNode = document.createElement('ul');
                await traverseDirectory(directoryHandle, rootNode);
                document.getElementById('directoryTree').appendChild(rootNode);
            } catch (err) {
                console.error('Error selecting directory:', err);
            }
        }

        async function traverseDirectory(directoryHandle, parentNode) {
            for await (const [name, handle] of directoryHandle.entries()) {
                const listItem = document.createElement('li');
                if (handle.kind === 'directory') {
                    listItem.className = 'folder';
                    listItem.textContent = name;
                    const subList = document.createElement('ul');
                    listItem.appendChild(subList);
                    listItem.addEventListener('click', async () => {
                        if (subList.childElementCount === 0) {
                            await traverseDirectory(handle, subList);
                        } else {
                            subList.classList.toggle('hidden');
                        }
                    });
                } else if (handle.kind === 'file' && name.endsWith('.h')) { // Modify this line to filter for font files
                    listItem.className = 'file';
                    listItem.textContent = name;
                    listItem.addEventListener('click', () => {
                        loadFile(handle);
                    });
                }
                parentNode.appendChild(listItem);
            }
        }

        async function loadFile(fileHandle) {
            const file = await fileHandle.getFile();
            const content = await file.text();
            document.getElementById('fileContent').value = content;
            executeFontPreview(content); // Automatically preview the font
        }


document.getElementById('FontPreview').addEventListener('click', function() {
    const fontData = document.getElementById('fileContent').value;
    executeFontPreview(fontData);
});
function executeFontPreview(content) {
	// Add your preview function here
	previewFont(content);
	console.log("Previewing font content:", content);
	// Call the actual font preview function with the content
}
		
function previewFont(fontData) {
    const canvas = document.getElementById('fontCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const { bitmaps, glyphs, FontHeight } = parseFontHeader(fontData);
    
    // console.log('Parsed Font Data:', { bitmaps, glyphs, FontHeight });
    
    if (!bitmaps.length || !glyphs.length || isNaN(FontHeight)) {
        console.error('Invalid font data parsed:', { bitmaps, glyphs, FontHeight });
        return;
    }

    let x = 5;
    const lineHeight = 30;
    let scaleFactor = parseFloat(document.getElementById('FontZoom').value);
    let y = FontHeight * scaleFactor;
    let renderedChars = [];

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        renderedChars.forEach(char => {
            const { imgData, posX, posY } = char;
            ctx.putImageData(imgData, posX, posY);
        });
    }
    
    glyphs.forEach(glyph => {
        const charImageData = getCharImageData(bitmaps, glyph);
        // console.log('Glyph:', glyph);

        if (glyph.width > 0 && glyph.height > 0) {
            const imgData = ctx.createImageData(glyph.width * scaleFactor, glyph.height * scaleFactor);
            const scaledCharImageData = scaleImageData(charImageData, glyph.width, glyph.height, scaleFactor);
            imgData.data.set(scaledCharImageData);
            
            // Check if y exceeds the canvas height
            if (y + lineHeight > canvas.height) {
                // Increase canvas height by a fixed amount (e.g., 200 pixels) or based on line height
                canvas.height += lineHeight + 10 * scaleFactor; // Add some padding
                render(); // Render everything again
            }
            
            ctx.putImageData(imgData, x, y - glyph.height * scaleFactor);
            renderedChars.push({ imgData, posX: x, posY: y - glyph.height * scaleFactor });

            x += (glyph.xAdvance * scaleFactor + 10);

            if (x > canvas.width - (glyph.width * scaleFactor)) {
                x = 10;
                y += lineHeight + FontHeight * scaleFactor;
            }
        } else {
            console.error('Invalid glyph data:', glyph);
        }
    });
    // Adjust canvas height to fit all rendered characters
    const lastChar = renderedChars[renderedChars.length - 1];
    const requiredHeight = lastChar ? lastChar.posY + lastChar.imgData.height : canvas.height;
    if (canvas.height !== requiredHeight) {
        canvas.height = requiredHeight;
        render(); // Render everything again with the adjusted canvas height
    }
}

function parseFontHeader(data) {
	/* 
		//Adafruit GFX Font Glyphs structure
		typedef struct {
		  uint16_t bitmapOffset; ///< Pointer into GFXfont->bitmap
		  uint8_t width;         ///< Bitmap dimensions in pixels
		  uint8_t height;        ///< Bitmap dimensions in pixels
		  uint8_t xAdvance;      ///< Distance to advance cursor (x axis)
		  int8_t xOffset;        ///< X dist from cursor pos to UL corner
		  int8_t yOffset;        ///< Y dist from cursor pos to UL corner
		} GFXglyph;
	*/
    const bitmaps = [];
    const glyphs = [];
    const bitmapRegex = /0x([0-9A-Fa-f]{2})/g;
    const glyphRegex = /{ +(\d+), +(\d+), +(\d+), +(\d+), +(\d+), +(\d+) }/g;

    let match;
    while ((match = bitmapRegex.exec(data)) !== null) {
        tes = bitmaps.push(parseInt(match[1], 16));
    }

    const regex = /,\s*(\d+)\s*\};/;
    const FontHeightMatch = data.match(regex);
    const FontHeight = parseInt(FontHeightMatch[1], 10);

    let currentBitmapOffset = 0;
    let oldOffset = 0;
    while ((match = glyphRegex.exec(data)) !== null) {
        const [_, bitmapOffset, width, height, xAdvance, xOffset, yOffset] = match.map(Number);
        if (width > 0 && height > 0) {
            oldOffset = currentBitmapOffset;
            if (oldOffset != bitmapOffset) {
                currentBitmapOffset += 1;
            }
            glyphs.push({ bitmapOffset, width, height, xAdvance, xOffset, yOffset, glyphOffset: currentBitmapOffset });
            currentBitmapOffset += Math.ceil((width * height) / 8);
            // console.log('oldOffset:', oldOffset);
            // console.log('currentBitmapOffset:', currentBitmapOffset);
            // console.log('bitmapOffset:', bitmapOffset, '\n\n');
        } else {
            // console.log('w=0 h=0:\n', oldOffset);
            glyphs.push({ bitmapOffset, width, height, xAdvance, xOffset, yOffset, glyphOffset: -1 });
        }
    }

    return { bitmaps, glyphs, FontHeight };
}

function getCharImageData(bitmaps, glyph) {
    const { width, height, glyphOffset } = glyph;
    if (glyphOffset === -1) {
        return new Uint8ClampedArray(width * height * 4);
    }
    const charData = new Uint8ClampedArray(width * height * 4);
    let byteIndex = glyphOffset;
    let bitIndex = 0;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const byte = bitmaps[byteIndex];
            const bit = (byte >> (7 - bitIndex)) & 1;
            const pixel = bit ? 255 : 0;
            const index = (y * width + x) * 4;
            charData[index] = pixel;
            charData[index + 1] = pixel;
            charData[index + 2] = pixel;
            charData[index + 3] = 255;

            bitIndex++;
            if (bitIndex === 8) {
                bitIndex = 0;
                byteIndex++;
            }
        }
    }

    return charData;
}

function scaleImageData(data, width, height, scaleFactor) {
    const scaledData = new Uint8ClampedArray(width * height * 4 * scaleFactor * scaleFactor);
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            for (let dy = 0; dy < scaleFactor; dy++) {
                for (let dx = 0; dx < scaleFactor; dx++) {
                    const scaledIndex = ((y * scaleFactor + dy) * width * scaleFactor + (x * scaleFactor + dx)) * 4;
                    scaledData[scaledIndex] = data[index];
                    scaledData[scaledIndex + 1] = data[index + 1];
                    scaledData[scaledIndex + 2] = data[index + 2];
                    scaledData[scaledIndex + 3] = data[index + 3];
                }
            }
        }
    }
    return scaledData;
}

		
		
		
    </script>
</body>
</html>
