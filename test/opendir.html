<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semantic UI Layout</title>
    <link rel="stylesheet" href="./semantic-ui/semantic.min.css">
    <script src="./semantic-ui/jquery-3.2.1.min.js"></script>
    <script src="./semantic-ui/semantic.min.js"></script>
    <style>
        body {
            scroll-behavior: smooth;
            background-color: #000;
            font-family: Verdana, sans-serif;
            color: #fbbd08;
        }

        .flex-container {
            display: flex;
            height: 100vh;
            margin-top: 20px;
        }

        .right-panel {
            flex-grow: 1;
            padding: 0 10px;
            overflow-y: auto;
        }

        .file-list {
            list-style: none;
            margin: 0 0 0 45px;
            padding: 0;
            width: max-content;
        }

        .file-list li {
            cursor: pointer;
            padding: 5px 10px;
            border: 1px solid #595959;
            border-radius: .28571429rem;
            margin-left: -15px;
        }

        .file-list li:hover {
            background-color: #011159;
        }

        .no-files {
            padding: 10px;
            color: #888;
            text-align: center;
        }

        canvas {
            max-width: 97%;
            margin-top: 30px;
        }

        .hidden {
            display: none;
        }

        .sidebar {
            height: 100%;
            width: 40px;
            position: fixed;
            z-index: 1;
            top: 0;
            background-color: #071c35;
            overflow-x: auto;
            transition: 0.5s;
            padding: 30px 10px 0 10px;
            white-space: nowrap;
        }

        .sidebar.left {
            left: 0;
			padding-right: 30px;
        }

        .sidebar.right {
            right: 0;
        }

        .sidebar a {
            text-decoration: none;
            font-size: 20px;
            color: #fbbd08;
            display: block;
            transition: 0.3s;
        }

        .sidebar a:hover {
            cursor: pointer;
            color: #fd0909;
        }

        #main {
            padding: 16px;
            margin-left: 40px;
        }

        @media screen and (max-height: 450px) {
            .sidebar {
                padding-top: 15px;
            }

            .sidebar a {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div style="margin-left:150px;padding-top:30px;">
        <h1>Adafruit GFX Font Preview</h1>
    </div>
    <div class="ui container">
        <div class="ui form">
            <div class="flex-container">
                <div id="mySidebarLeft" class="sidebar left" onmouseover="toggleSidebar('mySidebarLeft')" onmouseout="toggleSidebar('mySidebarLeft')">
                    <a href="#" id="openDirectoryButton">
                        <span><i class="folder open outline icon"></i></span>&nbsp;&nbsp;&nbsp;&nbsp;Open Folder
                    </a>
                </div>
                <div class="right-panel">
                    <textarea id="fileContent"></textarea>
                    <br><br>
                    Zoom Scale
                    <input class="puter" type="number" min="1" id="FontZoom" value="4" style="width: 70px;">
                    <button class="ui inverted violet button" onclick="previewFont()"><i class="icon upload"></i> Preview Font</button>
                    <input class="puter" type="number" id="baseValue" value="0" style="width:70px;">
                    <button class="ui small inverted blue button" onclick="zeroBase()">Rubah Base</button>
                    <br>
                    <canvas id="fontCanvas"></canvas>
                </div>
                <div id="mySidebarRight" class="sidebar right" onmouseover="toggleSidebar('mySidebarRight')" onmouseout="toggleSidebar('mySidebarRight')">
					<a href="#" id="rst" onclick="resetDirectoryTree()" style="display:none">
						<span><i class="trash icon"></i></span>&nbsp;&nbsp;&nbsp;&nbsp;Clear List
					</a>

                    <div class="file-list" id="directoryTree"></div>
                </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        var SidebarToggleLeft = true;
        var SidebarToggleRight = true;

        function toggleSidebar(sidebarId) {
            const sidebar = document.getElementById(sidebarId);
            const resetButton = sidebarId === 'mySidebarRight' ? document.getElementById('rst') : null;

            if (sidebarId === 'mySidebarLeft') {
                if (SidebarToggleLeft) {
                    sidebar.style.width = "max-content";
                } else {
                    sidebar.style.width = "40px";
                }
                SidebarToggleLeft = !SidebarToggleLeft;
            } else {
                if (SidebarToggleRight) {
                    sidebar.style.width = "max-content";
                    // if (resetButton) resetButton.style.display = "block";
                } else {
                    sidebar.style.width = "40px";
                    // if (resetButton) resetButton.style.display = "none";
                }
                SidebarToggleRight = !SidebarToggleRight;
            }
        }

        document.getElementById('openDirectoryButton').addEventListener('click', selectDirectory);

        const puterInputs = document.querySelectorAll('.puter');
        puterInputs.forEach(input => {
            input.addEventListener('wheel', function(e) {
                let currentValue = parseFloat(input.value) || 0;
                currentValue += e.deltaY > 0 ? -1 : 1;

                const min = parseFloat(input.min);
                const max = parseFloat(input.max);

                if (!isNaN(min)) currentValue = Math.max(currentValue, min);
                if (!isNaN(max)) currentValue = Math.min(currentValue, max);

                input.value = currentValue;
            });
        });
		
		
				
		async function selectDirectory() {
			try {
				let directoryHandle = await window.showDirectoryPicker();
				console.log('directoryHandle:', directoryHandle);

				const rootNode = document.createElement('ul');
				await traverseDirectory(directoryHandle, rootNode, true); // Pass true to indicate it's the root directory
				const directoryTree = document.getElementById('directoryTree');

				//directoryTree.innerHTML = ''; // Clear previous list
				directoryTree.appendChild(rootNode);

				// Show reset button if directory tree is not empty
				if (directoryTree.childElementCount > 0) {
					document.getElementById('rst').style.display = 'block';
				}
			} catch (err) {
				console.error('Error selecting directory:', err);
				alert('Error selecting directory: ' + err.message);
			}
		}

        async function traverseDirectory(directoryHandle, parentNode) {
            for await (const [name, handle] of directoryHandle.entries()) {
				// Skip files that don't end with .h
				if (handle.kind === 'file' && !name.endsWith('.h')) {
					continue;
				}
				
                const listItem = document.createElement('li');
                const itemText = document.createElement('span');
                itemText.textContent = name;
                listItem.appendChild(itemText);

                if (handle.kind === 'directory') {
                    listItem.className = 'folder';
                    listItem.style.backgroundColor = '#3d3637';
                    listItem.style.marginTop = '5px';
                    const subList = document.createElement('ul');
                    subList.style.borderRadius= '.28571429rem';
                    subList.classList.add('hidden');
                    listItem.appendChild(subList);

                    itemText.addEventListener('click', async () => {
                        if (subList.childElementCount === 0) {
                            await traverseDirectory(handle, subList);
                        }
                        subList.classList.toggle('hidden');
                    });
                } else if (handle.kind === 'file' && name.endsWith('.h')) {
                    listItem.className = 'file';
                    listItem.style.backgroundColor = '#331643';
                    listItem.addEventListener('click', () => loadFile(handle));
                }

                parentNode.appendChild(listItem);
            }
        }




        async function loadFile(fileHandle) {
            const file = await fileHandle.getFile();
            const content = await file.text();
            document.getElementById('fileContent').value = content;
            previewFont(content);
        }

function resetDirectoryTree() {
    const directoryTree = document.getElementById('directoryTree');
    directoryTree.innerHTML = '';
    const resetButtonRight = document.getElementById('rst');
    resetButtonRight.style.display = 'none';
}

function zeroBase() {
	const inputValue = parseInt(document.getElementById('baseValue').value, 10);
	let glyphArray = document.getElementById('fileContent').value;
	const regex = /(\{\s*\d+,\s*\d+,\s*\d+,\s*\d+,\s*\d+,\s*)(-?\d+)(\s*\})/g;

	glyphArray = glyphArray.replace(regex, (match, p1, p2, p3) => `${p1}${parseInt(p2, 10) + inputValue}${p3}`);

	document.getElementById('fileContent').value = glyphArray;
	previewFont(glyphArray);
	document.getElementById('baseValue').value = 0;
}

		
function previewFont() {
            const fontData = document.getElementById('fileContent').value;
    const canvas = document.getElementById('fontCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const { bitmaps, glyphs, FontHeight } = parseFontHeader(fontData);
    
    // console.log('Parsed Font Data:', { bitmaps, glyphs, FontHeight });
    
    if (!bitmaps.length || !glyphs.length || isNaN(FontHeight)) {
        console.error('Invalid font data parsed:', { bitmaps, glyphs, FontHeight });
        return;
    }

    let x = 5;
    const lineHeight = 30;
    let scaleFactor = parseFloat(document.getElementById('FontZoom').value,10);
    let y = FontHeight * scaleFactor;
    let renderedChars = [];

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        renderedChars.forEach(char => {
            const { imgData, posX, posY } = char;
            ctx.putImageData(imgData, posX, posY);
        });
    }
    
    glyphs.forEach(glyph => {
        const charImageData = getCharImageData(bitmaps, glyph);
        // console.log('Glyph:', glyph);

        if (glyph.width > 0 && glyph.height > 0) {
            const imgData = ctx.createImageData(glyph.width * scaleFactor, glyph.height * scaleFactor);
            const scaledCharImageData = scaleImageData(charImageData, glyph.width, glyph.height, scaleFactor);
            imgData.data.set(scaledCharImageData);
            
            // Check if y exceeds the canvas height
            if (y + lineHeight > canvas.height) {
                // Increase canvas height by a fixed amount (e.g., 200 pixels) or based on line height
                canvas.height += lineHeight + 10 * scaleFactor; // Add some padding
                render(); // Render everything again
            }
            
            ctx.putImageData(imgData, x, y - glyph.height * scaleFactor);
            renderedChars.push({ imgData, posX: x, posY: y - glyph.height * scaleFactor });

            x += (glyph.xAdvance * scaleFactor + 10);

            if (x > canvas.width - (glyph.width * scaleFactor)) {
                x = 10;
                y += lineHeight + FontHeight * scaleFactor;
            }
        } else {
            console.error('Invalid glyph data:', glyph);
        }
    });
    // Adjust canvas height to fit all rendered characters
    const lastChar = renderedChars[renderedChars.length - 1];
    const requiredHeight = lastChar ? lastChar.posY + lastChar.imgData.height : canvas.height;
    if (canvas.height !== requiredHeight) {
        canvas.height = requiredHeight;
        render(); // Render everything again with the adjusted canvas height
    }
}

function parseFontHeader(data) {
	/* 
		//Adafruit GFX Font Glyphs structure
		typedef struct {
		  uint16_t bitmapOffset; ///< Pointer into GFXfont->bitmap
		  uint8_t width;         ///< Bitmap dimensions in pixels
		  uint8_t height;        ///< Bitmap dimensions in pixels
		  uint8_t xAdvance;      ///< Distance to advance cursor (x axis)
		  int8_t xOffset;        ///< X dist from cursor pos to UL corner
		  int8_t yOffset;        ///< Y dist from cursor pos to UL corner
		} GFXglyph;
	*/
    const bitmaps = [];
    const glyphs = [];
    const bitmapRegex = /0x([0-9A-Fa-f]{2})/g;
    const glyphRegex = /{ +(\d+), +(\d+), +(\d+), +(\d+), +(\d+), +(\d+) }/g;

    let match;
    while ((match = bitmapRegex.exec(data)) !== null) {
        tes = bitmaps.push(parseInt(match[1], 16));
    }

    const regex = /,\s*(\d+)\s*\};/;
    const FontHeightMatch = data.match(regex);
    const FontHeight = parseInt(FontHeightMatch[1], 10);

    let currentBitmapOffset = 0;
    let oldOffset = 0;
    while ((match = glyphRegex.exec(data)) !== null) {
        const [_, bitmapOffset, width, height, xAdvance, xOffset, yOffset] = match.map(Number);
        if (width > 0 && height > 0) {
            oldOffset = currentBitmapOffset;
            if (oldOffset != bitmapOffset) {
                currentBitmapOffset += 1;
            }
            glyphs.push({ bitmapOffset, width, height, xAdvance, xOffset, yOffset, glyphOffset: currentBitmapOffset });
            currentBitmapOffset += Math.ceil((width * height) / 8);
            // console.log('oldOffset:', oldOffset);
            // console.log('currentBitmapOffset:', currentBitmapOffset);
            // console.log('bitmapOffset:', bitmapOffset, '\n\n');
        } else {
            // console.log('w=0 h=0:\n', oldOffset);
            glyphs.push({ bitmapOffset, width, height, xAdvance, xOffset, yOffset, glyphOffset: -1 });
        }
    }

    return { bitmaps, glyphs, FontHeight };
}

function getCharImageData(bitmaps, glyph) {
    const { width, height, glyphOffset } = glyph;
    if (glyphOffset === -1) {
        return new Uint8ClampedArray(width * height * 4);
    }
    const charData = new Uint8ClampedArray(width * height * 4);
    let byteIndex = glyphOffset;
    let bitIndex = 0;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const byte = bitmaps[byteIndex];
            const bit = (byte >> (7 - bitIndex)) & 1;
            const pixel = bit ? 255 : 0;
            const index = (y * width + x) * 4;
            charData[index] = pixel;
            charData[index + 1] = pixel;
            charData[index + 2] = pixel;
            charData[index + 3] = 255;

            bitIndex++;
            if (bitIndex === 8) {
                bitIndex = 0;
                byteIndex++;
            }
        }
    }

    return charData;
}

function scaleImageData(data, width, height, scaleFactor) {
    const scaledData = new Uint8ClampedArray(width * height * 4 * scaleFactor * scaleFactor);
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            for (let dy = 0; dy < scaleFactor; dy++) {
                for (let dx = 0; dx < scaleFactor; dx++) {
                    const scaledIndex = ((y * scaleFactor + dy) * width * scaleFactor + (x * scaleFactor + dx)) * 4;
                    scaledData[scaledIndex] = data[index];
                    scaledData[scaledIndex + 1] = data[index + 1];
                    scaledData[scaledIndex + 2] = data[index + 2];
                    scaledData[scaledIndex + 3] = data[index + 3];
                }
            }
        }
    }
    return scaledData;
}

    </script>
</body>
</html>
