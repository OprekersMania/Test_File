<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semantic UI Layout</title>
    <link rel="stylesheet" href="./semantic-ui/semantic.min.css">
    <script src="./semantic-ui/jquery-3.2.1.min.js"></script>
    <script src="./semantic-ui/semantic.min.js"></script>
    <style>
        body {
            scroll-behavior: smooth;
            background-color: #000;
            font-family: Verdana, sans-serif;
            color: #fbbd08;
        }

        .flex-container {
            display: flex;
            height: 100vh;
            margin-top: 20px;
        }

        .middle-panel {
            flex-grow: 1;
            padding: 0 10px;
            overflow-y: auto;
        }

        .file-list {
            list-style: none;
            margin: 30px 0 0 45px;
            padding: 0;
            width: max-content;
        }

        .file-list li {
            cursor: pointer;
            padding: 5px 10px;
            border-bottom: 1px solid #ddd;
            margin-left: -15px;
        }

        .file-list li:hover {
            background-color: #011159;
        }

        .no-files {
            padding: 10px;
            color: #888;
            text-align: center;
        }

        canvas {
            max-width: 97%;
            margin-top: 30px;
        }

        .hidden {
            display: none;
        }
/*--------------------------------*/
        .sidebar {
            height: 100%;
            width: 40px;
            position: fixed;
            z-index: 1;
            top: 0;
            left: 0;
            background-color: #071c35;
            overflow-x: auto;
            transition: 0.5s;
            padding: 30px 10px 0 10px;
            white-space: nowrap;
        }

        .sidebar a {
            /* padding: 8px;*/
            text-decoration: none;
            font-size: 20px;
            color: #4183c4;
            display: block;
            transition: 0.3s;
        }

        .sidebar a:hover {
            cursor: pointer;
            color: #fd0909;
        }
        .sidebar-text {
            vertical-align: middle;
        }
        #main {
            /* transition: margin-left .5s; */
            padding: 16px;
            margin-left: 40px;
        }
        /* On smaller screens, where height is less than 450px, change the style of the sidenav (less padding and a smaller font size) */

        @media screen and (max-height: 450px) {
            .sidebar {
                padding-top: 15px;
            }

            .sidebar a {
                font-size: 18px;
            }
        }
/*--------------------------------*/
    </style>
</head>
<body>
    <div style="margin-left:150px;padding-top:30px;">
        <h1>Adafruit GFX Font Preview</h1>
    </div>
    <div class="ui container">
        <div class="ui form">
            <div class="flex-container">
                <div id="mySidebar" class="sidebar" onmouseover="toggleSidebar()" onmouseout="toggleSidebar()">
                    <a href="#" id="openDirectoryButton">
                        <span><i class="folder open outline icon"></i></span>&nbsp;&nbsp;&nbsp;&nbsp;Open Folder
                    </a>
                    <button id="rst" onclick="resetDirectoryTree()" class="ui mini red button right floated" style="display:none">Reset List</button>
                    <div class="file-list" id="directoryTree"></div>
                </div>
                <div class="middle-panel">
                    <textarea id="fileContent"></textarea>
                    <br><br>
                    Zoom Scale
                    <input class="puter" type="number" min="1" id="FontZoom" value="4" style="width: 70px;">
                    <button class="ui inverted violet button" id="FontPreview"><i class="icon upload"></i> Preview Font</button>
                    <input class="puter" type="number" id="baseValue" value="0" style="width:70px;">
                    <button class="ui small inverted blue button" onclick="zeroBase()">Rubah Base</button>
                    <br>
                    <canvas id="fontCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        var SidebarToggle = true;

        function toggleSidebar() {
            const sidebar = document.getElementById("mySidebar");
            const resetButton = document.getElementById("rst");

            if (SidebarToggle) {
                sidebar.style.width = "max-content";
                resetButton.style.display = "block";
            } else {
                sidebar.style.width = "40px";
                resetButton.style.display = "none";
            }

            SidebarToggle = !SidebarToggle;
        }

        document.getElementById('openDirectoryButton').addEventListener('click', selectDirectory);

// Mengambil semua elemen input dengan class "puter"
        const puterInputs = document.querySelectorAll('.puter');
// Loop melalui setiap elemen input dan tambahkan event listener
        puterInputs.forEach(input => {
            input.addEventListener('wheel', function(e) {
        // Mengambil nilai saat ini dari input
                let currentValue = parseFloat(input.value) || 0;
        // Menyesuaikan nilai input berdasarkan arah scroll
                currentValue += e.deltaY > 0 ? -1 : 1;

        // Memastikan nilai tidak melebihi min atau max jika ada
                const min = parseFloat(input.min);
                const max = parseFloat(input.max);

                if (!isNaN(min)) currentValue = Math.max(currentValue, min);
                if (!isNaN(max)) currentValue = Math.min(currentValue, max);

        // Menetapkan nilai baru ke input
                input.value = currentValue;
            });
        });

        async function selectDirectory() {
            try {
                let directoryHandle;
            // Mencoba mendapatkan path terakhir dari localStorage
                const lastSelectedDirectory = localStorage.getItem('lastSelectedDirectory');

            // Cek apakah ada path terakhir yang disimpan di localStorage
                if (lastSelectedDirectory) {
                // Mencoba membuka directoryHandle berdasarkan path terakhir
                    directoryHandle = await getDirectoryHandle(lastSelectedDirectory);
                } else {
                // Jika tidak ada path terakhir di localStorage, tampilkan dialog untuk memilih direktori
                    directoryHandle = await window.showDirectoryPicker();
                }

            // Memuat struktur direktori ke dalam DOM
                const rootNode = document.createElement('ul');
                await traverseDirectory(directoryHandle, rootNode);
                document.getElementById('directoryTree').appendChild(rootNode);
            } catch (err) {
                console.error('Error selecting directory:', err);
                alert('Error selecting directory: ' + err.message);
            }
        }

    // Fungsi untuk menyimpan path terakhir yang dipilih ke dalam localStorage
        function saveLastSelectedDirectory(directoryPath) {
            localStorage.setItem('lastSelectedDirectory', directoryPath);
        }

    // Fungsi untuk mendapatkan directoryHandle berdasarkan directoryPath
        async function getDirectoryHandle(directoryPath) {
        // Mencoba mendapatkan directoryHandle berdasarkan directoryPath
            const directoryHandle = await navigator.storage.getDirectory(directoryPath);
        // Menyimpan path terakhir yang dipilih ke dalam localStorage
            saveLastSelectedDirectory(directoryPath);
            return directoryHandle;
        }

        async function traverseDirectory(directoryHandle, parentNode) {
            for await (const [name, handle] of directoryHandle.entries()) {
                const listItem = document.createElement('li');
                const itemText = document.createElement('span');
                itemText.textContent = name;
                listItem.appendChild(itemText);

                if (handle.kind === 'directory') {
                    listItem.className = 'folder';
                    listItem.style.backgroundColor = '#05432b';
                    const subList = document.createElement('ul');
		    subList.classList.add('hidden'); // Sembunyikan daftar file secara default
                    listItem.appendChild(subList);

                    itemText.addEventListener('click', async () => {
                        if (subList.childElementCount === 0) {
                            await traverseDirectory(handle, subList);
                        }
                        subList.classList.toggle('hidden');
                    });
                } else if (handle.kind === 'file' && name.endsWith('.h')) { // Ubah baris ini untuk memfilter file-font
                    listItem.className = 'file';
                    listItem.style.backgroundColor = '#590101';
                    listItem.addEventListener('click', () => loadFile(handle));
                }

                parentNode.appendChild(listItem);
            }
        }

    // Fungsi untuk memuat konten file ke dalam textarea
        async function loadFile(fileHandle) {
            const file = await fileHandle.getFile();
            const content = await file.text();
            document.getElementById('fileContent').value = content;
            executeFontPreview(content);// Automatically preview the font
	}

        function resetDirectoryTree() {
            const directoryTree = document.getElementById('directoryTree');
            directoryTree.innerHTML = ''; // Menghapus isi dari directoryTree
            localStorage.removeItem('lastSelectedDirectory'); // Menghapus path terakhir dari localStorage
        }

        function zeroBase() {
            const inputValue = parseInt(document.getElementById('baseValue').value, 10);
            let glyphArray = document.getElementById('fileContent').value;
            const regex = /(\{\s*\d+,\s*\d+,\s*\d+,\s*\d+,\s*\d+,\s*)(-?\d+)(\s*\})/g;

            glyphArray = glyphArray.replace(regex, (match, p1, p2, p3) => `${p1}${parseInt(p2, 10) + inputValue}${p3}`);

            document.getElementById('fileContent').value = glyphArray;
            executeFontPreview(glyphArray);
            document.getElementById('baseValue').value = 0;
        }

        document.getElementById('FontPreview').addEventListener('click', () => {
            const fontData = document.getElementById('fileContent').value;
            executeFontPreview(fontData);
        });

function executeFontPreview(content) {
	// Add your preview function here
	previewFont(content);
	console.log("Previewing font content:", content);
	// Call the actual font preview function with the content
}
		
function previewFont(fontData) {
    const canvas = document.getElementById('fontCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const { bitmaps, glyphs, FontHeight } = parseFontHeader(fontData);
    
    // console.log('Parsed Font Data:', { bitmaps, glyphs, FontHeight });
    
    if (!bitmaps.length || !glyphs.length || isNaN(FontHeight)) {
        console.error('Invalid font data parsed:', { bitmaps, glyphs, FontHeight });
        return;
    }

    let x = 5;
    const lineHeight = 30;
    let scaleFactor = parseFloat(document.getElementById('FontZoom').value,10);
    let y = FontHeight * scaleFactor;
    let renderedChars = [];

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        renderedChars.forEach(char => {
            const { imgData, posX, posY } = char;
            ctx.putImageData(imgData, posX, posY);
        });
    }
    
    glyphs.forEach(glyph => {
        const charImageData = getCharImageData(bitmaps, glyph);
        // console.log('Glyph:', glyph);

        if (glyph.width > 0 && glyph.height > 0) {
            const imgData = ctx.createImageData(glyph.width * scaleFactor, glyph.height * scaleFactor);
            const scaledCharImageData = scaleImageData(charImageData, glyph.width, glyph.height, scaleFactor);
            imgData.data.set(scaledCharImageData);
            
            // Check if y exceeds the canvas height
            if (y + lineHeight > canvas.height) {
                // Increase canvas height by a fixed amount (e.g., 200 pixels) or based on line height
                canvas.height += lineHeight + 10 * scaleFactor; // Add some padding
                render(); // Render everything again
            }
            
            ctx.putImageData(imgData, x, y - glyph.height * scaleFactor);
            renderedChars.push({ imgData, posX: x, posY: y - glyph.height * scaleFactor });

            x += (glyph.xAdvance * scaleFactor + 10);

            if (x > canvas.width - (glyph.width * scaleFactor)) {
                x = 10;
                y += lineHeight + FontHeight * scaleFactor;
            }
        } else {
            console.error('Invalid glyph data:', glyph);
        }
    });
    // Adjust canvas height to fit all rendered characters
    const lastChar = renderedChars[renderedChars.length - 1];
    const requiredHeight = lastChar ? lastChar.posY + lastChar.imgData.height : canvas.height;
    if (canvas.height !== requiredHeight) {
        canvas.height = requiredHeight;
        render(); // Render everything again with the adjusted canvas height
    }
}

function parseFontHeader(data) {
	/* 
		//Adafruit GFX Font Glyphs structure
		typedef struct {
		  uint16_t bitmapOffset; ///< Pointer into GFXfont->bitmap
		  uint8_t width;         ///< Bitmap dimensions in pixels
		  uint8_t height;        ///< Bitmap dimensions in pixels
		  uint8_t xAdvance;      ///< Distance to advance cursor (x axis)
		  int8_t xOffset;        ///< X dist from cursor pos to UL corner
		  int8_t yOffset;        ///< Y dist from cursor pos to UL corner
		} GFXglyph;
	*/
    const bitmaps = [];
    const glyphs = [];
    const bitmapRegex = /0x([0-9A-Fa-f]{2})/g;
    const glyphRegex = /{ +(\d+), +(\d+), +(\d+), +(\d+), +(\d+), +(\d+) }/g;

    let match;
    while ((match = bitmapRegex.exec(data)) !== null) {
        tes = bitmaps.push(parseInt(match[1], 16));
    }

    const regex = /,\s*(\d+)\s*\};/;
    const FontHeightMatch = data.match(regex);
    const FontHeight = parseInt(FontHeightMatch[1], 10);

    let currentBitmapOffset = 0;
    let oldOffset = 0;
    while ((match = glyphRegex.exec(data)) !== null) {
        const [_, bitmapOffset, width, height, xAdvance, xOffset, yOffset] = match.map(Number);
        if (width > 0 && height > 0) {
            oldOffset = currentBitmapOffset;
            if (oldOffset != bitmapOffset) {
                currentBitmapOffset += 1;
            }
            glyphs.push({ bitmapOffset, width, height, xAdvance, xOffset, yOffset, glyphOffset: currentBitmapOffset });
            currentBitmapOffset += Math.ceil((width * height) / 8);
            // console.log('oldOffset:', oldOffset);
            // console.log('currentBitmapOffset:', currentBitmapOffset);
            // console.log('bitmapOffset:', bitmapOffset, '\n\n');
        } else {
            // console.log('w=0 h=0:\n', oldOffset);
            glyphs.push({ bitmapOffset, width, height, xAdvance, xOffset, yOffset, glyphOffset: -1 });
        }
    }

    return { bitmaps, glyphs, FontHeight };
}

function getCharImageData(bitmaps, glyph) {
    const { width, height, glyphOffset } = glyph;
    if (glyphOffset === -1) {
        return new Uint8ClampedArray(width * height * 4);
    }
    const charData = new Uint8ClampedArray(width * height * 4);
    let byteIndex = glyphOffset;
    let bitIndex = 0;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const byte = bitmaps[byteIndex];
            const bit = (byte >> (7 - bitIndex)) & 1;
            const pixel = bit ? 255 : 0;
            const index = (y * width + x) * 4;
            charData[index] = pixel;
            charData[index + 1] = pixel;
            charData[index + 2] = pixel;
            charData[index + 3] = 255;

            bitIndex++;
            if (bitIndex === 8) {
                bitIndex = 0;
                byteIndex++;
            }
        }
    }

    return charData;
}

function scaleImageData(data, width, height, scaleFactor) {
    const scaledData = new Uint8ClampedArray(width * height * 4 * scaleFactor * scaleFactor);
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            for (let dy = 0; dy < scaleFactor; dy++) {
                for (let dx = 0; dx < scaleFactor; dx++) {
                    const scaledIndex = ((y * scaleFactor + dy) * width * scaleFactor + (x * scaleFactor + dx)) * 4;
                    scaledData[scaledIndex] = data[index];
                    scaledData[scaledIndex + 1] = data[index + 1];
                    scaledData[scaledIndex + 2] = data[index + 2];
                    scaledData[scaledIndex + 3] = data[index + 3];
                }
            }
        }
    }
    return scaledData;
}


    </script>
</body>
</html>
